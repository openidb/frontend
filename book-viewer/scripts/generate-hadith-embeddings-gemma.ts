/**
 * Generate Hadith Embeddings with Local EmbeddingGemma-300M
 *
 * Creates a new Qdrant collection (sunnah_hadiths_gemma) with 768-dimensional
 * embeddings generated by the local EmbeddingGemma model.
 *
 * Prerequisites:
 *   1. Start embedding server: cd embedding-server && uvicorn main:app --port 8000
 *   2. Ensure hadiths are in database: bun run scripts/scrape-sunnah.ts
 *
 * Usage:
 *   bun run scripts/generate-hadith-embeddings-gemma.ts [--force] [--batch-size=50]
 *
 * Options:
 *   --force         Re-generate embeddings even if they already exist
 *   --batch-size=N  Number of hadiths to process in each batch (default: 50)
 */

import "dotenv/config";
import crypto from "crypto";
import { prisma } from "../lib/db";
import { qdrant } from "../lib/qdrant";
import { EMBEDDINGGEMMA_DIMENSIONS } from "../lib/constants";
import {
  generateEmbeddingsLocal,
  normalizeArabicText,
  truncateForEmbedding,
  isEmbeddingServerAvailable,
  getEmbeddingServerHealth,
} from "../lib/embeddings-local";

// Collection name for EmbeddingGemma hadiths
const QDRANT_HADITH_GEMMA_COLLECTION = "sunnah_hadiths_gemma";

// Collections that use /collection/book/hadith format instead of /collection:hadith
const BOOK_PATH_COLLECTIONS = new Set(["malik", "bulugh"]);

function generateSunnahComUrl(collectionSlug: string, hadithNumber: string, bookNumber: number): string {
  const cleanHadithNumber = hadithNumber.replace(/[A-Za-z]+$/, "");
  if (BOOK_PATH_COLLECTIONS.has(collectionSlug)) {
    return `https://sunnah.com/${collectionSlug}/${bookNumber}/${cleanHadithNumber}`;
  }
  return `https://sunnah.com/${collectionSlug}:${cleanHadithNumber}`;
}

// Parse command line arguments
const forceFlag = process.argv.includes("--force");
const batchSizeArg = process.argv.find((arg) => arg.startsWith("--batch-size="));
const BATCH_SIZE = batchSizeArg
  ? parseInt(batchSizeArg.split("=")[1], 10)
  : 50;

/**
 * Generate a deterministic point ID for hadiths
 */
function generateHadithPointId(
  collectionSlug: string,
  hadithNumber: string
): string {
  const input = `hadith_gemma_${collectionSlug}_${hadithNumber}`;
  return crypto.createHash("md5").update(input).digest("hex");
}

/**
 * Initialize Hadith Gemma collection if it doesn't exist
 */
async function initializeCollection(): Promise<void> {
  try {
    const collections = await qdrant.getCollections();
    const exists = collections.collections.some(
      (c) => c.name === QDRANT_HADITH_GEMMA_COLLECTION
    );

    if (exists && forceFlag) {
      console.log(`Deleting existing collection: ${QDRANT_HADITH_GEMMA_COLLECTION}`);
      await qdrant.deleteCollection(QDRANT_HADITH_GEMMA_COLLECTION);
    }

    if (!exists || forceFlag) {
      console.log(`Creating collection: ${QDRANT_HADITH_GEMMA_COLLECTION}`);
      await qdrant.createCollection(QDRANT_HADITH_GEMMA_COLLECTION, {
        vectors: {
          size: EMBEDDINGGEMMA_DIMENSIONS,
          distance: "Cosine",
        },
        optimizers_config: {
          indexing_threshold: 10000,
        },
      });

      // Create payload indexes for filtering
      await qdrant.createPayloadIndex(QDRANT_HADITH_GEMMA_COLLECTION, {
        field_name: "collectionSlug",
        field_schema: "keyword",
      });
      await qdrant.createPayloadIndex(QDRANT_HADITH_GEMMA_COLLECTION, {
        field_name: "bookNumber",
        field_schema: "integer",
      });
      await qdrant.createPayloadIndex(QDRANT_HADITH_GEMMA_COLLECTION, {
        field_name: "hadithNumber",
        field_schema: "keyword",
      });

      console.log("Collection created with payload indexes\n");
    } else {
      console.log(`Collection already exists: ${QDRANT_HADITH_GEMMA_COLLECTION}\n`);
    }
  } catch (error) {
    console.error("Error initializing collection:", error);
    throw error;
  }
}

/**
 * Get existing point IDs from Qdrant to skip already processed hadiths
 */
async function getExistingPointIds(): Promise<Set<string>> {
  if (forceFlag) {
    return new Set();
  }

  try {
    const existingIds = new Set<string>();
    let offset: string | null = null;

    while (true) {
      const result = await qdrant.scroll(QDRANT_HADITH_GEMMA_COLLECTION, {
        limit: 1000,
        offset: offset ?? undefined,
        with_payload: false,
        with_vector: false,
      });

      for (const point of result.points) {
        existingIds.add(point.id as string);
      }

      if (!result.next_page_offset) {
        break;
      }
      offset = result.next_page_offset as string;
    }

    return existingIds;
  } catch {
    // Collection might be empty or not exist
    return new Set();
  }
}

/**
 * Process a batch of hadiths: generate embeddings and upsert to Qdrant
 */
async function processBatch(
  hadiths: Array<{
    id: number;
    hadithNumber: string;
    textArabic: string;
    textPlain: string;
    chapterArabic: string | null;
    chapterEnglish: string | null;
    book: {
      bookNumber: number;
      nameArabic: string;
      nameEnglish: string;
      collection: {
        slug: string;
        nameArabic: string;
        nameEnglish: string;
      };
    };
  }>
): Promise<number> {
  // Prepare texts for embedding - use plain text for better semantic matching
  const texts = hadiths.map((hadith) => {
    const normalized = normalizeArabicText(hadith.textPlain);
    return truncateForEmbedding(normalized);
  });

  // Generate embeddings using local server
  const embeddings = await generateEmbeddingsLocal(texts);

  // Prepare points for Qdrant
  const points = hadiths.map((hadith, index) => ({
    id: generateHadithPointId(hadith.book.collection.slug, hadith.hadithNumber),
    vector: embeddings[index],
    payload: {
      collectionSlug: hadith.book.collection.slug,
      collectionNameArabic: hadith.book.collection.nameArabic,
      collectionNameEnglish: hadith.book.collection.nameEnglish,
      bookNumber: hadith.book.bookNumber,
      bookNameArabic: hadith.book.nameArabic,
      bookNameEnglish: hadith.book.nameEnglish,
      hadithNumber: hadith.hadithNumber,
      text: hadith.textArabic,
      textPlain: hadith.textPlain,
      chapterArabic: hadith.chapterArabic,
      chapterEnglish: hadith.chapterEnglish,
      sunnahComUrl: generateSunnahComUrl(hadith.book.collection.slug, hadith.hadithNumber, hadith.book.bookNumber),
    },
  }));

  // Upsert to Qdrant
  await qdrant.upsert(QDRANT_HADITH_GEMMA_COLLECTION, {
    wait: true,
    points,
  });

  return points.length;
}

async function main() {
  console.log("=".repeat(60));
  console.log("HADITH EMBEDDINGS (EmbeddingGemma-300M)");
  console.log("=".repeat(60));
  console.log(`Collection: ${QDRANT_HADITH_GEMMA_COLLECTION}`);
  console.log(`Dimensions: ${EMBEDDINGGEMMA_DIMENSIONS}`);
  console.log(`Batch size: ${BATCH_SIZE}`);
  console.log(`Mode: ${forceFlag ? "Force regenerate all" : "Skip existing"}`);
  console.log();

  // Check if embedding server is available
  console.log("Checking embedding server availability...");
  const serverAvailable = await isEmbeddingServerAvailable();

  if (!serverAvailable) {
    console.error("ERROR: Local embedding server is not available!");
    console.error("Please start the server first:");
    console.error("  cd embedding-server && uvicorn main:app --port 8000");
    process.exit(1);
  }

  // Get server health info
  const health = await getEmbeddingServerHealth();
  console.log(`Server status: ${health.status}`);
  console.log(`Model: ${health.model}`);
  console.log(`Device: ${health.device}`);
  console.log();

  // Initialize collection
  await initializeCollection();

  // Get existing point IDs to skip
  console.log("Checking for existing embeddings...");
  const existingIds = await getExistingPointIds();
  console.log(`Found ${existingIds.size} existing embeddings\n`);

  // Get total hadith count
  const totalHadiths = await prisma.hadith.count();
  console.log(`Total hadiths in database: ${totalHadiths}\n`);

  if (totalHadiths === 0) {
    console.log("No hadiths found in database. Run scrape-sunnah.ts first.");
    return;
  }

  let processed = 0;
  let skipped = 0;
  let failed = 0;
  let offset = 0;
  const startTime = Date.now();

  while (offset < totalHadiths) {
    // Fetch batch of hadiths with book and collection info
    const hadiths = await prisma.hadith.findMany({
      skip: offset,
      take: BATCH_SIZE,
      orderBy: [{ bookId: "asc" }, { hadithNumber: "asc" }],
      select: {
        id: true,
        hadithNumber: true,
        textArabic: true,
        textPlain: true,
        chapterArabic: true,
        chapterEnglish: true,
        book: {
          select: {
            bookNumber: true,
            nameArabic: true,
            nameEnglish: true,
            collection: {
              select: {
                slug: true,
                nameArabic: true,
                nameEnglish: true,
              },
            },
          },
        },
      },
    });

    if (hadiths.length === 0) break;

    // Filter out already processed hadiths
    const hadithsToProcess = hadiths.filter((hadith) => {
      const pointId = generateHadithPointId(
        hadith.book.collection.slug,
        hadith.hadithNumber
      );
      if (existingIds.has(pointId)) {
        skipped++;
        return false;
      }
      return true;
    });

    if (hadithsToProcess.length > 0) {
      try {
        const count = await processBatch(hadithsToProcess);
        processed += count;

        const elapsed = (Date.now() - startTime) / 1000;
        const rate = processed / elapsed;
        const eta = (totalHadiths - processed - skipped) / rate;

        console.log(
          `Processed ${processed}/${totalHadiths} hadiths ` +
            `(skipped: ${skipped}, failed: ${failed}) ` +
            `[${rate.toFixed(1)}/s, ETA: ${Math.ceil(eta)}s]`
        );
      } catch (error) {
        console.error(`Batch failed:`, error);
        failed += hadithsToProcess.length;
      }
    }

    offset += hadiths.length;

    // Brief pause between batches to not overwhelm the server
    await new Promise((resolve) => setTimeout(resolve, 10));
  }

  const totalTime = (Date.now() - startTime) / 1000;

  console.log("\n" + "=".repeat(60));
  console.log("EMBEDDING GENERATION SUMMARY");
  console.log("=".repeat(60));
  console.log(`Processed: ${processed}`);
  console.log(`Skipped:   ${skipped}`);
  console.log(`Failed:    ${failed}`);
  console.log(`Total time: ${totalTime.toFixed(1)}s`);
  console.log(`Rate: ${(processed / totalTime).toFixed(1)} hadiths/s`);
  console.log("=".repeat(60));

  // Verify collection
  try {
    const info = await qdrant.getCollection(QDRANT_HADITH_GEMMA_COLLECTION);
    console.log(`\nCollection points: ${info.points_count}`);
  } catch (error) {
    console.error("Could not get collection info:", error);
  }

  console.log("\nEmbedding generation completed!");
}

main()
  .catch((e) => {
    console.error("\nEmbedding generation failed:");
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
